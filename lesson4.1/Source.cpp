/***
 * Требуется:
 * 1. Реализовать алгоритм медленной сортировки (один из: сортировка выбором, вставками, пузырьком)
 * 2. Реализовать алгоритм быстрой сортировки (сортировка Хоара или сортировка слиянием)
 * 3. Реализовать алгоритмы поиска элемента в отсортированном массиве (тривиальный алгоритм, бинарный поиск)
* Вопросы к заданию:
 * 1. Определить зависимость времени работы медленной сортировки (сортировки выбором) от числа элементов массива
 - Смотри график 1.
 * 2. Определить зависимость времени работы быстрой сортировки (сортировка Хоара/сортировка слиянием)  от числа элементов массива
 - Смотри график 2
 * 3. Определить количество элементов массива при котором медленная сортировка работает быстрее быстрой. - Примерно 10
 * 4. Определить зависимость времени работы тривиального поиска от количества элементов массива и количества запросов поиска
 - Что сие такое?
 * 5. Определить зависимость времени работы бинарного поиска от количества элементов массива и количества запросов поиска
 - Смотри график 3. Это зависимость от числа запросов, а зависимость от числа элементов массиво равно константе, так как
 происходит одновеменное уменьшение и увеличение времени: Увеличивается количество итераций на поиск элемента, но концентрация
 этих элементов и шанс нахождения на очень раннем шаге увеличивается
 * 6. Обменяться кодами быстрой сортировки с одногрупниками, провести исследование времени работы альтернативного алгоритма.
 - А может не надо...
 * 7. Определить диапазоны значений параметра N, для которых тот или иной алгоритм сортировки применим
 - Примерно 120000, так как далее проблемы со стеком
 * 8. Определите максимальное значение параметра MAX_N (с точностью до десятков тысяч) при котором программа может работать
 - Примерно 120000, так как далее проблемы со стеком
*/

#include <iostream>
#include "extension.hpp"


unsigned long long const MAX_N = 100000; //Максимальное количество элементов в массиве

//******************************Поиск элемента в массиве**********************************

//Напишите здесь функцию, которая выполняет поиск заданного элемента в массиве и возвращает его индекс

int BinSearch(long int A[], long int key, long int low, long int high)
{
    if (low > high)
    {
        return -1;
    }
    int mid = (low + high) / 2;
    if (A[mid] == key)
    {
        return mid;
    }
    if (A[mid] < key)
        return BinSearch(A, key, mid + 1, high);
    if (A[mid] > key)
        return BinSearch(A, key, low, mid - 1);
}

//***************************************************************************************

//***********************Сортировка выбором********************************************

//Напишите здесь функцию, которая выполняет сортировку пузырьком переданного ей массива

void easysort(long int A[], long int size)
{
    for (long int i = 0; i < size - 1; i++)
    {
        long int min_i = i;
        for (long int j = i + 1; j < size; j++)
        {
            if (A[j] < A[min_i])
            {
                min_i = j;
            }
        }
        
        if (min_i != i)
            std::swap(A[i], A[min_i]);
    }
}

//***************************************************************************************

//**********************************Сортировака слиянием*********************************

//Напишите здесь функцию, которая выполняет сортировку массива слиянием (если от вас это требуется)

//***************************************************************************************

//**********************************Сортировка Хоара*************************************

//Напишите здесь функцию, которая выполняет сортировку Хоара для переданного ей массива (если от вас это требуется)

void hardsort (long int A[], long int first, long int last)
{

    int i = first, j = last;
    double tmp, x = A[(first + last) / 2];
    do {
        while (A[i] < x)
            i++;
        while (A[j] > x)
            j--;

        if (i <= j)
        {
            if (i < j)
            {
                tmp = A[i];
                A[i] = A[j];
                A[j] = tmp;
            }
            i++;
            j--;
        }
    } while (i <= j);

    if (i < last)
        hardsort(A, i, last);
    if (first < j)
        hardsort(A, first, j);
}

//***************************************************************************************

void search_test_function(long A[MAX_N], unsigned long N, unsigned long requests_counts){
  Utils util;
  long *requests =new long[requests_counts];
  util.generate_data(requests, requests, requests_counts);

  Timer t; t.start();
  unsigned long misses = 0;
  for (auto i = 0ul; i < requests_counts; ++i){
    unsigned long index = 0;
    index = BinSearch(A, requests[i], 0, N);
    //index =  .... ; Разместите вызов вашей функции поиска элемента requests[i] в массиве A здесь
    if (index >= N){
      ++misses;
    }
    if (index < N && A[index] != requests[i]){
      std::cout << "Fail to search " << requests[i] << ". A[index] == " << A[index] << std::endl;
      return;
    }
    
  }
  t.stop();

  std::cout << "Processed " << requests_counts << " requests for array size " << N << ". Missed "<< misses
            << " requests. Elapsed time: "
            << t.elapsed() << " microseconds." << std::endl;

  delete[] requests;
}

int main() {
  Utils util;

  long slow_data[MAX_N], rapid_data[MAX_N];

  unsigned long const N = 1000; //Варьируемый параметр. Можно смело изменять для получения зависимости времени от N. N <= MAX_N

  //Генерация N произвольных числе из отрезка [-1000, 1000] в массивы slow_data и rapid_data. slow_data[i] == rapid_data[i]
  util.generate_data(slow_data, rapid_data, N);

  //*****************************Тестирование медленной сортировки******************************************************
  {
    Timer t;
    t.start();

    //Разместите вызов функции медленной сортировки для массива slow_data здесь
    easysort(slow_data, N);


    t.stop();

    if (!util.check_order(slow_data, N)) {
      std::cout << "Sort order is wrong. Check the sort function." << std::endl;
    } else {
      std::cout << "Performed slow sort of " << N << " elements. Elapsed time: " << t.elapsed() << " microseconds.\n" ;
    }
    std::cout << "First min(" << N << ", 10) elements:\n";
    for (auto i = 0; i < std::min(N, 10ul); ++i)
      std::cout << slow_data[i] << " ";
    std::cout << std::endl;
    
  }
  //********************************************************************************************************************
  
  //*****************************Тестирование быстрой сортировки********************************************************
  {
    Timer t;
    t.start();

    //Разместите вызов функции быстрой сортировки для массива rapid_data здесь
    hardsort(rapid_data, 0, N-1);



    t.stop();

    if (!util.check_order(rapid_data, N)) {
      std::cout << "Sort order is wrong. Check the sort function." << std::endl;
    } else {
      std::cout << "Performed rapid sort of " << N << " elements. Elapsed time: " << t.elapsed() << " microseconds.\n";
    }

    std::cout << "First min(" << N << ", 10) elements:\n";
    for (auto i = 0; i < std::min(N, 10ul); ++i)
      std::cout << rapid_data[i] << " ";
    std::cout << std::endl;
  }
  //********************************************************************************************************************

  //*****************************Тестирование поиска элемента в массиве*************************************************
  unsigned long request_count = 50000; //Количество запросов поиска. Можно варьировать в неограниченных (в разумной степени) пределах
  search_test_function(slow_data, N, request_count);
  //********************************************************************************************************************
  return 0;
}